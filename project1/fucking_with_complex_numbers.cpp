#include <complex>
#include <iostream>

int main (void) {
    std::complex<float> i = {0,1};
    std::complex<std::complex<float>> n = {i,1};
    std::complex<std::complex<float>> m = {-i,1};

    // The ring C = R[i] is isomorphic to R[X]/(1+X^2),
    // because i is defined to be a root of 1 + X^2 and 1 + X^2 is an irreducible polynomial
    // (note that it has a second root -i, and that we might as well have defined C = R[-i])

    // Because 1+X^2 is irreducible, it is even a field because R is a factorization domain, so R[X] is,
    // Hence by irreducibility of 1+X^2, (1+X^2) is maximal, and the quotient ring with a maximal ideal 
    // is a field. So C ~ R[X]/(1+X^2) is a field.

    // Further, the isomorphism maps i to (X mod 1 +X^2) in R[X]/(1+X^2) and 1 to (1 mod 1 _X^2).

    // C++ supports a complex type, std::complex<T> where T is an numeric type
    // The language does not reduce a complex<complex<T>> to a complex<T> automatically.
    // This is not a liberally taken design choice: you cannot make the compiler reduce 

    // std::complex<std::complex<float>> m = {-i,1};

    // to a std::complex<float> value, because it is unclear what i is at compile time (i.e. it might have been changed 
    // as a side effect) unless i was a constexpr


    // Knowing that nested complex types are possible, I wondered what kind of ring this would make. Let's call this ring
    // CC for a moment.
    // Now, essentially we are taking the ring R[i] and add another element to it, j, such that 1+j^2 = 0.
    // This makes CC = R[i][j] = R[i][Y]/(1+Y^2) = R[X,Y]/(1+X^2,1+Y^2).
    // We recognize zero divisors -X+Y and X+Y whose product is 0 mod (1+X^2,1+Y^2). In fact, we can apply the Chinese 
    // remainder theorem: (-i + Y) and (i + Y) are coprime (2i is unit) in C, hence their intersection must be ((-i+Y)*(1+Y)) = (1+Y^2), 
    // giving the isomorphism:

    // CC ~ C[i][Y]/(1+Y^2) ~ C[i][Y]/((-i+Y)*(i+Y)) ~ C[i][Y]/(-i+Y) x C[i][Y]/(i+Y)
    
    // For linear polynomials a+bY, we know R[Y]/(a+bY) ~ R for any ring R (by the evaluation homomorphism, for example), 
    // Hence CC ~ C x C where we send:

    // 1 -> the identity element (1,1) of C[i] x C[i], by the fact that isomorphisms are homomorphisms
    // i -> (i mod 1+Y^2) in C[i][Y]/(1+Y^2) -> ((i mod i + Y), (i mod -i + Y)) in C[i][Y]/(-i+Y) x C[i][Y]/(i+Y) -> (i, i) in C[i] x C[i]
    // j -> (Y mod 1+Y^2) in C[i][Y]/(1+Y^2) -> ((Y mod i + Y), (Y mod -i + Y)) = (-i mod i +Y, i mod -i + Y) in  C[i][Y]/(-i+Y) x C[i][Y]/(i+Y) -> (-i, i) in C[i] x C[i]

    // And this fixes the thus defined isomorphism on CC, for CC is generated by these elements for sure (in fact, even by {i,j}).

    // Hence, we can also conclude:
    
    // i*j -> (-i,i)*(i,i) = (1,-1)

    // Having a basis {(1,-1),(1,1)} for C x C,  this helps identify zero divisors, because these should have the form (c,0) or (0,c) in the direct product C[i] x C[i],
    // and these elements correspond to:

    // (2,0) = (1,-1) + (1,1), so corresponds to i*j + 1
    // (0,2) = -(1,-1) + (1,1), so corresponds to  1 - i*j

    // Giving that all zero divisors must be in the span of i*j + 1 or in the span of 1 - i*j, because only that can lead to an element with one
    // zero component in the direct product, and since C is a field only these elements can be zero divisors in C x C.

    // To demonstrate these esoteric contemplations in C++, here is a display of zero divisors in the ring of std::complex<std::complex<float>> type:

    std::cout << "n = " << n << std::endl;
    std::cout << "m = " << m << std::endl;
    std::cout << "n * m = " << n * m << std::endl;
    return 0;
}